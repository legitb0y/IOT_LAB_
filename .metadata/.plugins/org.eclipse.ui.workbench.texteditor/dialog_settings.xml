<?xml version="1.0" encoding="UTF-8"?>
<section name="Workbench">
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog">
		<item key="selection" value="user_uart_callback"/>
		<item key="wrap" value="true"/>
		<item key="casesensitive" value="false"/>
		<item key="wholeword" value="false"/>
		<item key="incremental" value="false"/>
		<item key="isRegEx" value="false"/>
		<list key="findhistory">
			<item value="user_uart_callback"/>
			<item value="is_data_received"/>
			<item value="R_SCI_UART_Close"/>
			<item value="R_SCI_UART_Open"/>
			<item value="R_SCI_UART_Read"/>
			<item value="R_SCI_UART_Create"/>
			<item value="R_SCI_UART_Write"/>
			<item value="/*&#x0A;* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates&#x0A;*&#x0A;* SPDX-License-Identifier: BSD-3-Clause&#x0A;*/&#x0A;&#x0A;#include &quot;hal_data.h&quot;&#x0A;#include &quot;stdio.h&quot;&#x0A;#include &quot;string.h&quot; // Thêm để sử dụng strncmp và atoi&#x0A;&#x0A;void R_BSP_WarmStart(bsp_warm_start_event_t event);&#x0A;void user_uart_callback(uart_callback_args_t *p_args);&#x0A;void console_write(const char *buffer);&#x0A;void process_uart_command(const char *command);&#x0A;&#x0A;static volatile bool is_transfer_complete = false;&#x0A;extern bsp_leds_t g_bsp_leds;&#x0A;&#x0A;void hs300x_callback(rm_hs300x_callback_args_t * p_args);&#x0A;static volatile bool hs300x_complete = false;&#x0A;&#x0A;static uint32_t humidity_threshold = 65; // Ngưỡng độ ẩm mặc định&#x0A;&#x0A;/*******************************************************************************************************************//**&#x0A;* @brief  Blinky example application&#x0A;*&#x0A;* Blinks all leds at a rate of 1 second using the software delay function provided by the BSP.&#x0A;*&#x0A;**********************************************************************************************************************/&#x0A;void hal_entry (void)&#x0A;{&#x0A;#if BSP_TZ_SECURE_BUILD&#x0A;    /* Enter non-secure code */&#x0A;    R_BSP_NonSecureEnter();&#x0A;#endif&#x0A;&#x0A;    /* Define the units to be used with the software delay function */&#x0A;    const bsp_delay_units_t bsp_delay_units = BSP_DELAY_UNITS_MILLISECONDS;&#x0A;&#x0A;    /* Set the blink frequency (must be &lt;= bsp_delay_units */&#x0A;    const uint32_t freq_in_hz = 1;&#x0A;&#x0A;    /* Calculate the delay in terms of bsp_delay_units */&#x0A;    const uint32_t delay = bsp_delay_units * 2 / freq_in_hz;&#x0A;&#x0A;    /* LED type structure */&#x0A;    bsp_leds_t leds = g_bsp_leds;&#x0A;&#x0A;    /* If this board has no LEDs then trap here */&#x0A;    if (0 == leds.led_count)&#x0A;    {&#x0A;        while (1)&#x0A;        {&#x0A;            ; // There are no LEDs on this board&#x0A;        }&#x0A;    }&#x0A;&#x0A;    char write_buffer[200] = {};&#x0A;    fsp_err_t err = FSP_SUCCESS;&#x0A;    rm_hs300x_raw_data_t hs300x_raw_data;&#x0A;    rm_hs300x_data_t hs300x_data;&#x0A;    uint8_t calculated_flag = 0;&#x0A;&#x0A;    R_SCI_UART_Open(&amp;g_uart0_ctrl, &amp;g_uart0_cfg);&#x0A;    rm_comms_i2c_bus_extended_cfg_t * p_extend_hs300x =&#x0A;        (rm_comms_i2c_bus_extended_cfg_t *)g_hs300x_sensor0_cfg.p_instance-&gt;p_cfg-&gt;p_extend;&#x0A;    i2c_master_instance_t * p_driver_instance_hs300x = (i2c_master_instance_t *) p_extend_hs300x-&gt;p_driver_instance;&#x0A;    p_driver_instance_hs300x-&gt;p_api-&gt;open(p_driver_instance_hs300x-&gt;p_ctrl, p_driver_instance_hs300x-&gt;p_cfg);&#x0A;&#x0A;    /* Initialize sensor */&#x0A;    RM_HS300X_Open(&amp;g_hs300x_sensor0_ctrl, &amp;g_hs300x_sensor0_cfg);&#x0A;&#x0A;    R_BSP_PinAccessEnable();&#x0A;    while(1)&#x0A;    {&#x0A;        /* Check for incoming UART commands */&#x0A;        char command_buffer[200] = {};&#x0A;        // Read command from UART (assuming you have a function to handle this)&#x0A;        // e.g., read_uart_command(command_buffer);&#x0A;        // process_uart_command(command_buffer);&#x0A;&#x0A;        /* Delete old log in tera term */&#x0A;        sprintf(write_buffer, &quot;\x1b[H&quot;);&#x0A;        console_write(write_buffer);&#x0A;&#x0A;        hs300x_complete = false;&#x0A;        /* Start Measurement */&#x0A;        RM_HS300X_MeasurementStart(&amp;g_hs300x_sensor0_ctrl);&#x0A;        while (false == hs300x_complete)&#x0A;        {&#x0A;            /* Wait callback */&#x0A;        }&#x0A;        do&#x0A;        {&#x0A;            hs300x_complete = false;&#x0A;            /* Read ADC Data from HS300X */&#x0A;            RM_HS300X_Read(&amp;g_hs300x_sensor0_ctrl, &amp;hs300x_raw_data);&#x0A;            while (false == hs300x_complete)&#x0A;            {&#x0A;                /* Wait callback */&#x0A;            }&#x0A;            /* Calculate Humidity and Temperature values from ADC data */&#x0A;            err = RM_HS300X_DataCalculate(&amp;g_hs300x_sensor0_ctrl, &amp;hs300x_raw_data, &amp;hs300x_data);&#x0A;            if (FSP_SUCCESS == err)&#x0A;            {&#x0A;                calculated_flag = 1;&#x0A;            }&#x0A;            else if (FSP_ERR_SENSOR_INVALID_DATA == err)&#x0A;            {&#x0A;                /* Stale data */&#x0A;                calculated_flag = 0;&#x0A;            }&#x0A;        } while (0 == calculated_flag);&#x0A;&#x0A;        uint32_t pinRed = leds.p_leds[0];&#x0A;        uint32_t pinGreen = leds.p_leds[1];&#x0A;        uint32_t RGBRedPin = leds.p_leds[3];&#x0A;        uint32_t RGBGreenPin = leds.p_leds[4];&#x0A;        uint32_t pinBlue = leds.p_leds[5];&#x0A;&#x0A;        // Turn off blue LED&#x0A;        R_BSP_PinWrite((bsp_io_port_pin_t)pinBlue, BSP_IO_LEVEL_HIGH);&#x0A;&#x0A;        if(hs300x_data.humidity.integer_part &gt; humidity_threshold)&#x0A;        {&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinRed, BSP_IO_LEVEL_HIGH);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinGreen, BSP_IO_LEVEL_LOW);&#x0A;&#x0A;            // RGB&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGBRedPin, BSP_IO_LEVEL_LOW);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGBGreenPin, BSP_IO_LEVEL_HIGH);&#x0A;        }&#x0A;        else&#x0A;        {&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinRed, BSP_IO_LEVEL_LOW);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinGreen, BSP_IO_LEVEL_HIGH);&#x0A;&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGBGreenPin, BSP_IO_LEVEL_LOW);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGB"/>
			<item value="/*&#x0A;* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates&#x0A;*&#x0A;* SPDX-License-Identifier: BSD-3-Clause&#x0A;*/&#x0A;&#x0A;#include &quot;hal_data.h&quot;&#x0A;#include &quot;stdio.h&quot;&#x0A;#include &quot;string.h&quot; // Thêm để sử dụng strncmp và atoi&#x0A;&#x0A;void R_BSP_WarmStart(bsp_warm_start_event_t event);&#x0A;void user_uart_callback(uart_callback_args_t *p_args);&#x0A;void console_write(const char *buffer);&#x0A;void process_uart_command(const char *command);&#x0A;&#x0A;static volatile bool is_transfer_complete = false;&#x0A;extern bsp_leds_t g_bsp_leds;&#x0A;&#x0A;void hs300x_callback(rm_hs300x_callback_args_t * p_args);&#x0A;static volatile bool hs300x_complete = false;&#x0A;&#x0A;static uint32_t humidity_threshold = 65; // Ngưỡng độ ẩm mặc định&#x0A;&#x0A;/*******************************************************************************************************************//**&#x0A;* @brief  Blinky example application&#x0A;*&#x0A;* Blinks all leds at a rate of 1 second using the software delay function provided by the BSP.&#x0A;*&#x0A;**********************************************************************************************************************/&#x0A;void hal_entry (void)&#x0A;{&#x0A;#if BSP_TZ_SECURE_BUILD&#x0A;    /* Enter non-secure code */&#x0A;    R_BSP_NonSecureEnter();&#x0A;#endif&#x0A;&#x0A;    /* Define the units to be used with the software delay function */&#x0A;    const bsp_delay_units_t bsp_delay_units = BSP_DELAY_UNITS_MILLISECONDS;&#x0A;&#x0A;    /* Set the blink frequency (must be &lt;= bsp_delay_units */&#x0A;    const uint32_t freq_in_hz = 1;&#x0A;&#x0A;    /* Calculate the delay in terms of bsp_delay_units */&#x0A;    const uint32_t delay = bsp_delay_units * 2 / freq_in_hz;&#x0A;&#x0A;    /* LED type structure */&#x0A;    bsp_leds_t leds = g_bsp_leds;&#x0A;&#x0A;    /* If this board has no LEDs then trap here */&#x0A;    if (0 == leds.led_count)&#x0A;    {&#x0A;        while (1)&#x0A;        {&#x0A;            ; // There are no LEDs on this board&#x0A;        }&#x0A;    }&#x0A;&#x0A;    char write_buffer[200] = {};&#x0A;    fsp_err_t err = FSP_SUCCESS;&#x0A;    rm_hs300x_raw_data_t hs300x_raw_data;&#x0A;    rm_hs300x_data_t hs300x_data;&#x0A;    uint8_t calculated_flag = 0;&#x0A;&#x0A;    R_SCI_UART_Open(&amp;g_uart0_ctrl, &amp;g_uart0_cfg);&#x0A;    rm_comms_i2c_bus_extended_cfg_t * p_extend_hs300x =&#x0A;        (rm_comms_i2c_bus_extended_cfg_t *)g_hs300x_sensor0_cfg.p_instance-&gt;p_cfg-&gt;p_extend;&#x0A;    i2c_master_instance_t * p_driver_instance_hs300x = (i2c_master_instance_t *) p_extend_hs300x-&gt;p_driver_instance;&#x0A;    p_driver_instance_hs300x-&gt;p_api-&gt;open(p_driver_instance_hs300x-&gt;p_ctrl, p_driver_instance_hs300x-&gt;p_cfg);&#x0A;&#x0A;    /* Initialize sensor */&#x0A;    RM_HS300X_Open(&amp;g_hs300x_sensor0_ctrl, &amp;g_hs300x_sensor0_cfg);&#x0A;&#x0A;    R_BSP_PinAccessEnable();&#x0A;    while(1)&#x0A;    {&#x0A;        /* Check for incoming UART commands */&#x0A;        char command_buffer[200] = {};&#x0A;        // Read command from UART (assuming you have a function to handle this)&#x0A;        // e.g., read_uart_command(command_buffer);&#x0A;        // process_uart_command(command_buffer);&#x0A;&#x0A;        /* Delete old log in tera term */&#x0A;        sprintf(write_buffer, &quot;\x1b[H&quot;);&#x0A;        console_write(write_buffer);&#x0A;&#x0A;        hs300x_complete = false;&#x0A;        /* Start Measurement */&#x0A;        RM_HS300X_MeasurementStart(&amp;g_hs300x_sensor0_ctrl);&#x0A;        while (false == hs300x_complete)&#x0A;        {&#x0A;            /* Wait callback */&#x0A;        }&#x0A;        do&#x0A;        {&#x0A;            hs300x_complete = false;&#x0A;            /* Read ADC Data from HS300X */&#x0A;            RM_HS300X_Read(&amp;g_hs300x_sensor0_ctrl, &amp;hs300x_raw_data);&#x0A;            while (false == hs300x_complete)&#x0A;            {&#x0A;                /* Wait callback */&#x0A;            }&#x0A;            /* Calculate Humidity and Temperature values from ADC data */&#x0A;            err = RM_HS300X_DataCalculate(&amp;g_hs300x_sensor0_ctrl, &amp;hs300x_raw_data, &amp;hs300x_data);&#x0A;            if (FSP_SUCCESS == err)&#x0A;            {&#x0A;                calculated_flag = 1;&#x0A;            }&#x0A;            else if (FSP_ERR_SENSOR_INVALID_DATA == err)&#x0A;            {&#x0A;                /* Stale data */&#x0A;                calculated_flag = 0;&#x0A;            }&#x0A;        } while (0 == calculated_flag);&#x0A;&#x0A;        uint32_t pinRed = leds.p_leds[0];&#x0A;        uint32_t pinGreen = leds.p_leds[1];&#x0A;        uint32_t RGBRedPin = leds.p_leds[3];&#x0A;        uint32_t RGBGreenPin = leds.p_leds[4];&#x0A;        uint32_t pinBlue = leds.p_leds[5];&#x0A;&#x0A;        // Turn off blue LED&#x0A;        R_BSP_PinWrite((bsp_io_port_pin_t)pinBlue, BSP_IO_LEVEL_HIGH);&#x0A;&#x0A;        if(hs300x_data.humidity.integer_part &gt; humidity_threshold)&#x0A;        {&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinRed, BSP_IO_LEVEL_HIGH);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinGreen, BSP_IO_LEVEL_LOW);&#x0A;&#x0A;            // RGB&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGBRedPin, BSP_IO_LEVEL_LOW);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGBGreenPin, BSP_IO_LEVEL_HIGH);&#x0A;        }&#x0A;        else&#x0A;        {&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinRed, BSP_IO_LEVEL_LOW);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)pinGreen, BSP_IO_LEVEL_HIGH);&#x0A;&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGBGreenPin, BSP_IO_LEVEL_LOW);&#x0A;            R_BSP_PinWrite((bsp_io_port_pin_t)RGB&#x0A;"/>
			<item value="threshold"/>
		</list>
		<list key="replacehistory">
		</list>
	</section>
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog_dialogBounds">
		<item key="DIALOG_X_ORIGIN" value="1434"/>
		<item key="DIALOG_Y_ORIGIN" value="222"/>
		<item key="DIALOG_WIDTH" value="363"/>
		<item key="DIALOG_HEIGHT" value="437"/>
		<item key="DIALOG_FONT_NAME" value="1|Ubuntu|11.0|0|GTK|1|"/>
	</section>
</section>
